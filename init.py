#!/usr/bin/env python3

# Initialize Makefile and some skeleton test code.
# Generally this is run once (and after a header is added),
# and the resulting changes are checked in, so you don't need to run this
# unless you're hacking on this project.

from dataclasses import dataclass
import glob


# All cxx-lib headers.  (The project only provides headers!)
# These are, roughly, topologically-sorted; least-dependent to most-dependent.
# This way we can test smaller / simpler components, make sure they function,
# and then work our way up to the bigger / more-dependent parts.
headers = [
    "Util.h",
    "StackTrace.h",
    "Exception.h",
    "Ref.h",
    "Generator.h",
    "String.h",
    "JSON.h",
]


@dataclass
class Target:
    name: str           # RefTests.ubsan
    deps: list[str]     # RefTests.cc **/*.h builddir
    build: str = ""     # clang++ [...] -sanitize=undefined -o RefTests.ubsan -c test/RefTests.cc

    def print(self, targets: dict[str, "Target"], visited_names: set[str] | None = None):
        """Print self in Makefile rule format."""

        if visited_names is None:
            visited_names = set()
        if self.name in visited_names:
            return

        visited_names.add(self.name)

        line = self.name
        line += ":"
        for dep in self.deps:
            line += " " + dep
        print(line)
        if self.build:
            print("\t" + self.build)
        print()

        for dep in self.deps:
            if dep in targets:
                targets[dep].print(targets, visited_names)


class Makefile:
    def __init__(self) -> None:
        self.targets: dict[str, Target] = {}
        self.roots = [
            # "Apex" target, this is built by just running `make`
            self.add(Target("all", deps=[])),
            self.add(Target("clean", [], "rm -rf build/"))
        ]
    
    def add(self, target: Target) -> Target:
        assert target.name not in self.targets
        self.targets[target.name] = target
        return target

    def target(self, name: str) -> Target:
        return self.targets[name]

    def build(self) -> Target:
        # All tests depend on these
        builddir_target = self.add(Target("builddir", deps=[], build="mkdir -p build"))

        # All headers are to be listed as dependencies;
        # not just public ones, but the `detail` headers also.
        globbed_headers = glob.glob("src/**/*.h")
        all_headers = self.add(Target("all_headers", deps=globbed_headers))

        def make_test_target(test_prog: str, test_cc: str, suf: str, san: str) -> Target:
            return Target(
                name=test_prog,
                deps=[test_cc] + [all_headers.name] + [builddir_target.name],
                build=f"clang++ @compile_flags.txt @debugging_flags.txt -fsanitize={san} -o {test_prog} {test_cc}")

        for header in headers:
            base_name = header.rstrip(".h")
            test_cc = f"test/{base_name}Tests.cc"

            # asan, ubsan, etc. tests for this one test
            group: list[Target] = []

            # TODO add tsan=thread, msan=memory (which skips on OSX)
            for (suf, san) in (("asan", "address"), ("ubsan", "undefined"), ("tsan", "thread")):
                test_prog = f"build/{base_name}Tests.{suf}"
                group.append(self.add(make_test_target(test_prog, test_cc, suf, san)))

            # add one target for all flavors of this test
            test_progs = [p.name for p in group]
            test_target = self.add(
                Target(
                    name=f"{base_name}Tests",
                    deps=[t.name for t in group],
                    build=(" && ".join(test_progs))))

            # add under "all" target
            self.target("all").deps.append(test_target.name)

        return self
    
    def print(self) -> None:
        print("# Auto-generated by init.py")
        for root in self.roots:
            root.print(self.targets)


if __name__ == "__main__":
    Makefile().build().print()
